//package maze;


import java.io.FileNotFoundException;
import java.util.*;

/**
 *  Contains the maze struture, which is just an array of 
 *  <code>MazeCell</code>s.  Also contains the algorithms
 *  for generating and solving the maze.
 *
 */
public class Maze {

	private int rows, cols, wallDestructions, time;
	private MazeCell maze[][];
	//the UI code is all in MazeViewer.java
	private MazeViewer viewer;
	//This is just for random number generation
	private Random generator;
	private MazeCell startCell;
	private MazeCell endCell;
	private MazeCell current;
	private Scanner in;
	private DisjointSet ds;
	//	private ArrayList<MazeCell> allCells;
	//	private HashMap<MazeCell, LinkedList<MazeCell>> allCells;
	private ArrayList<MazeCell> allCells;
	private Queue<MazeCell> q;
	private ArrayList<MazeCell> traversedCells; 


	/**
	 *  Creates a maze that has the given number of rows and columns.
	 *  Sets the neighbors of each cell.
	 *  @param rows  Number of rows in the maze.
	 *  @param cols  Number of columns in the maze.
	 */
	public Maze(int rows, int cols) {
		this.rows = rows;
		this.cols = cols;
		generator = new Random();
		wallDestructions = 0;
		current = new MazeCell();
		ds = new DisjointSet();
		//		allCells = new HashMap<MazeCell, LinkedList<MazeCell>>();
		allCells = new ArrayList<MazeCell>();
		q = new LinkedList<>();
		traversedCells = new ArrayList<MazeCell>();
		time = 0;

		// Create the maze.     
		maze = new MazeCell[rows][cols];
		for (int i=0; i<rows; i++) {
			for (int j=0; j<cols; j++) {
				maze[i][j] = new MazeCell();
			}
		}

		// Set the neighbors for each cell in the maze.
		for (int i=0; i<rows; i++) {
			for (int j=0; j<cols; j++) {
				MazeCell n, e, s, w;
				if (i == 0) n = null; // On north border of maze
				else n = maze[i-1][j]; 

				if (i == rows-1) s = null; // On south border of maze
				else s = maze[i+1][j];

				if (j == 0) w = null; // On west border of maze
				else w = maze[i][j-1];

				if (j == cols-1) e = null; // On east border of maze
				else e = maze[i][j+1];

				maze[i][j].setNeighbors(n,e,s,w);
			}
		}

	}


	/**
	 *  Accessor that sets the <code>MazeViewer</code> variable for
	 *  the maze.  When the viewer is not set, no visualization takes place.
	 *  @param viewer Visual display place for the maze.
	 */
	public void setViewer(MazeViewer viewer) {
		this.viewer = viewer;
	}

	/**
	 *  Accessor that sets the start cell for the maze.
	 *  @param cell Start cell for the maze.
	 */
	public void setStartCell(MazeCell cell) {
		startCell = cell;
	}

	/**
	 *  Accessor that sets the end cell for the maze.
	 *  @param cell End cell for the maze.
	 */
	public void setEndCell(MazeCell cell) {
		endCell = cell;
	}

	/**
	 *  Accessor that returns the start cell for the maze.
	 *  @return Start cell for the maze.
	 */
	public MazeCell getStartCell() {
		return startCell;
	}

	/**
	 *  Accessor that returns the end cell for the maze.
	 *  @return End cell for the maze.
	 */
	public MazeCell getEndCell() {
		return endCell;
	}

	/**
	 *  Accessor that returns the number of rows in the maze.
	 *  @return The number of rows in the maze.
	 */
	public int getRows() {
		return rows;
	}

	/**
	 *  Accessor that returns the number of columns in the maze.
	 *  @return The number of columns in the maze.
	 */
	public int getCols() {
		return cols;
	}

	/**
	 *  Returns the cell in the maze at the given coordinates.
	 *  @param row  The row in the maze of the cell.
	 *  @param col  The column in the maze of the cell.
	 *  @return  The cell at (<code>row</code>, <code>col</code>)
	 */
	public MazeCell getCell(int row, int col) {
		MazeCell target = new MazeCell();
		try{
			target = maze[row][col];
		} catch (IndexOutOfBoundsException ioobe){
			System.out.println("Indices provided are outside of matrix!");
		}
		return target;
	}

	/**
	 *  Tells the viewer to show the maze again, with 
	 *  any changes to cells updated.  The current cell 
	 *  will be colored in the viewer.  If the viewer is null,
	 *  this method does nothing.
	 *  @param cell Current cell, that the viewer will color.
	 */
	public synchronized void visualize(MazeCell cell) {
		viewer.visualize(cell);
	}

	/**
	 *  Generates the maze. 
	 *  The maze is generated by Kruskal's algorithm
	 */
	public synchronized void generateMaze() {
		makeKruskalMaze();
		//you can change the startCell and endCell values
		startCell = maze[0][0];
		endCell = maze[rows-1][cols-1];
	}


	/**
	 *  Forms the maze via Kruskal's algorithm.
	 */
	public synchronized void makeKruskalMaze() {
		ds.makeSet(maze);
		current = new MazeCell();
		//		current = getStartCell();
		//		current = startCell;
		current = maze[0][0];
		allCells.add(current);
		MazeCell neighbor = new MazeCell();
		int totalCells = (getRows() * getCols());
		//		while(wallDestructions < totalCells - 1) {
		while(current != maze[rows-1][cols-1]) {
			if(current.getRandomNeighbor(current) != null){
				neighbor = current.getRandomNeighbor(current);
			} else {
				while(neighbor == null){
					Random rand = new Random();
					int randRow = rand.nextInt(rows - 1);
					int randCol = rand.nextInt(cols - 1);
					neighbor = getCell(randRow, randCol);
				}
			}
			if(neighbor != null){
				ds.union(current, neighbor);
				current.knockDownWall(current, neighbor);
				if(allCells.contains(neighbor)){
					allCells.add(neighbor);
				}
			} 
			current = neighbor;
			if(allCells.contains(current)){
				allCells.add(current);
			}
			wallDestructions = wallDestructions + 1;
		}
	}

	/**
	 *  Solve maze.  The input parameter is guaranteed
	 *  to be one of "dfs", "bfs",  or "random".
	 *  @param method The method for solving the maze; one of
	 *                "dfs" = depth first search, 
	 *                "bfs" = breadth first search, 
	 *                "random" = random walk.
	 */
	public synchronized void solveMaze(String method) {
		if(method.contains("dfs") || method.equalsIgnoreCase("dfs")){
			solveDFSMaze();
		} else if (method.contains("bfs") || method.equalsIgnoreCase("bfs")){
			solveBFSMaze();
		} else if (method.contains("random") || method.equalsIgnoreCase("random")){
			solveRandomMaze();
		} else {
			System.out.println("Please input a valid parameter: 'dfs', 'bfs', or 'random'");
			in = new Scanner(System.in);
			String input = in.next();
			solveMaze(input);
		}
	}

	/**
	 *  Solves the maze by randomly choosing a neighboring
	 *  cell to explore. This method has been written for you.
	 *  Please note this method takes a very long time
	 *  to complete.
	 */
	public synchronized void solveRandomMaze() {
		// Start the search at the start cell
		MazeCell current = startCell;

		// while we haven't reached the end of the maze
		while(current != endCell) { 
			visualize(current); // show the progress visually (repaint)
			ArrayList<MazeCell> neighbors = current.getNeighbors(current);
			int index = generator.nextInt(neighbors.size());
			current.examine();
			current = neighbors.get(index);    
		}
		visualize(current);
	}

	/**
	 *  Solves the maze by depth first search.
	 */
	public synchronized void solveDFSMaze() {
		// Start the search at the start cell
		MazeCell current = startCell;
		runDFS(current);
		//				// while we haven't reached the end of the maze
		//				while(current != endCell) { 
		//					visualize(current); // show the progress visually (repaint)
		//					ArrayList<MazeCell> neighbors = current.getNeighbors(current);
		//					int index = generator.nextInt(neighbors.size());
		//					current.examine();
		//					current = neighbors.get(index);    
		//				}
		//				visualize(current);
	}




	/**
	 * The primary method that implements the DFSvisit method
	 * @param start a MazeCell start value
	 */
	public void runDFS(MazeCell start) {
		//		MazeCell current = startCell;
		MazeCell current = start;
		for(MazeCell mc : allCells){
			mc.color = "white";
			mc.predecessor = null;
		}
		time = 0;
		if(current != null){
			visualize(current);
			current.examine();
			DFSvisit(allCells, current);
		}
		for(MazeCell cell : allCells){
			if(cell.color.equalsIgnoreCase("white")){
				DFSvisit(allCells, cell);
			}
		}
		System.out.println("DFS has finished!");
	}

	/**
	 * The recursive method that forms part of the overall DFS running
	 * @param allCells a list of all MazeCell objects in graph
	 * @param current the current MazeCell being discovered
	 * 
	 * current = 'u' ; c = 'v'
	 */
	public void DFSvisit(List<MazeCell> listOfCells, MazeCell current) {
		LinkedList<MazeCell> adjacencies = new LinkedList<>();
		time = time + 1;
		current.start = time;
		current.color = "gray";

		while(current != endCell) { 
			visualize(current); // show the progress visually (repaint)
			ArrayList<MazeCell> neighbors = current.getNeighbors(current);
			int index = generator.nextInt(neighbors.size());
			current.examine();
			
			if(!neighbors.get(index).hasAllWalls(neighbors.get(index)) || !current.sharesWallWith(current, neighbors.get(index))){
				current = neighbors.get(index);    
			}
    
		}

		if(current.neighborE != null && current.east() == false){
			adjacencies.add(current.neighborE);
		} else if (current.neighborN != null && current.north() == false){
			adjacencies.add(current.neighborN);
		}else if (current.neighborS != null && current.south() == false){
			adjacencies.add(current.neighborN);
		}else if (current.neighborW != null && current.west() == false){
			adjacencies.add(current.neighborN);
		}

		//need to iterate over all adjacencies to current cell
		if(adjacencies != null){
			for(MazeCell c : adjacencies){
				if(c != null){
					if(c.color.equalsIgnoreCase("white")){
						c.predecessor = current;
						DFSvisit(allCells, c);
					}
				}
			}
		}
		current.color = "black";
		time = time + 1;
		current.finish = time;
	}


	/**
	 *  Solves the maze by breadth first search.
	 *  starts at the start vertex and stops when bfs
	 *  discovers the end vertex
	 */
	public synchronized void solveBFSMaze() {
		//TODO - do a BFS implementation
		LinkedList<MazeCell> adjacencies = new LinkedList<>();

		for(MazeCell cellName : allCells) { //might need to change this
			cellName.color = "white";
			cellName.distance = 0;
			cellName.predecessor = null;
		}
		//		startCell = allCells.get(startCell);
		startCell.color = "white";
		startCell.distance = 0;
		startCell.predecessor = null;

		q.add(startCell);
		while(q.isEmpty() == false){
			MazeCell u = q.remove();
			u.visit();
			while(u != endCell) { 
				visualize(u); // show the progress visually (repaint)
				ArrayList<MazeCell> neighbors = u.getNeighbors(u);
				int index = generator.nextInt(neighbors.size());
				u.examine();
				if(!neighbors.get(index).hasAllWalls(neighbors.get(index))  || !u.sharesWallWith(u, neighbors.get(index))){
					u = neighbors.get(index);    
				}
			}

			traversedCells.add(u);
			if(u.neighborE != null && u.east() == false){
				adjacencies.add(u.neighborE);
			} else if (u.neighborN != null && u.north() == false){
				adjacencies.add(u.neighborN);
			}else if (u.neighborS != null && u.south() == false){
				adjacencies.add(u.neighborN);
			}else if (u.neighborW != null && u.west() == false){
				adjacencies.add(u.neighborN);
			}


			//		LinkedList<MazeCell> linked = allCells.get(u);
			if(adjacencies != null){
				for(MazeCell cell : adjacencies){
					if(cell != null){
						MazeCell currentCell = new MazeCell();
						currentCell = cell;
						if(currentCell.color.equals("white")){
							currentCell.color = "gray";
							currentCell.distance = u.distance + 1;
							currentCell.predecessor = u;
							//						System.out.println("node: " + currentNode.value + ", node distance:" + currentNode.distance + " , predecessor: " + currentNode.predecessor.value);
							if(!traversedCells.contains(currentCell)){
								q.add(currentCell);
							}
						}
						adjacencies.remove(cell);
					}
				}
			}
			u.color = "black";
			u.examine();
		}
		System.out.println("BFS has finished running!");	
	}


}
