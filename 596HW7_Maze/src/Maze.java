//package maze;


import java.util.*;

/**
 *  Contains the maze struture, which is just an array of 
 *  <code>MazeCell</code>s.  Also contains the algorithms
 *  for generating and solving the maze.
 *
 */
public class Maze {

	private int rows, cols, wallDestructions;
	private MazeCell maze[][];
	//the UI code is all in MazeViewer.java
	private MazeViewer viewer;
	//This is just for random number generation
	private Random generator;
	private MazeCell startCell;
	private MazeCell endCell;
	private MazeCell current;
	private Scanner in;
	private DisjointSet ds;
	//	private ArrayList<MazeCell> allCells;
	private HashMap<MazeCell, LinkedList<MazeCell>> allCells;
	private Queue<MazeCell> q;
	private ArrayList<MazeCell> traversedCells; 


	/**
	 *  Creates a maze that has the given number of rows and columns.
	 *  Sets the neighbors of each cell.
	 *  @param rows  Number of rows in the maze.
	 *  @param cols  Number of columns in the maze.
	 */
	public Maze(int rows, int cols) {
		this.rows = rows;
		this.cols = cols;
		generator = new Random();
		wallDestructions = 0;
		current = new MazeCell();
		ds = new DisjointSet();
		allCells = new HashMap<MazeCell, LinkedList<MazeCell>>();
		q = new LinkedList<>();
		traversedCells = new ArrayList<MazeCell>();

		// Create the maze.     
		maze = new MazeCell[rows][cols];
		for (int i=0; i<rows; i++) {
			for (int j=0; j<cols; j++) {
				maze[i][j] = new MazeCell();
			}
		}

		// Set the neighbors for each cell in the maze.
		for (int i=0; i<rows; i++) {
			for (int j=0; j<cols; j++) {
				MazeCell n, e, s, w;
				if (i == 0) n = null; // On north border of maze
				else n = maze[i-1][j]; 

				if (i == rows-1) s = null; // On south border of maze
				else s = maze[i+1][j];

				if (j == 0) w = null; // On west border of maze
				else w = maze[i][j-1];

				if (j == cols-1) e = null; // On east border of maze
				else e = maze[i][j+1];

				maze[i][j].setNeighbors(n,e,s,w);
			}
		}

	}


	/**
	 *  Accessor that sets the <code>MazeViewer</code> variable for
	 *  the maze.  When the viewer is not set, no visualization takes place.
	 *  @param viewer Visual display place for the maze.
	 */
	public void setViewer(MazeViewer viewer) {
		this.viewer = viewer;
	}

	/**
	 *  Accessor that sets the start cell for the maze.
	 *  @param cell Start cell for the maze.
	 */
	public void setStartCell(MazeCell cell) {
		startCell = cell;
	}

	/**
	 *  Accessor that sets the end cell for the maze.
	 *  @param cell End cell for the maze.
	 */
	public void setEndCell(MazeCell cell) {
		endCell = cell;
	}

	/**
	 *  Accessor that returns the start cell for the maze.
	 *  @return Start cell for the maze.
	 */
	public MazeCell getStartCell() {
		return startCell;
	}

	/**
	 *  Accessor that returns the end cell for the maze.
	 *  @return End cell for the maze.
	 */
	public MazeCell getEndCell() {
		return endCell;
	}

	/**
	 *  Accessor that returns the number of rows in the maze.
	 *  @return The number of rows in the maze.
	 */
	public int getRows() {
		return rows;
	}

	/**
	 *  Accessor that returns the number of columns in the maze.
	 *  @return The number of columns in the maze.
	 */
	public int getCols() {
		return cols;
	}

	/**
	 *  Returns the cell in the maze at the given coordinates.
	 *  @param row  The row in the maze of the cell.
	 *  @param col  The column in the maze of the cell.
	 *  @return  The cell at (<code>row</code>, <code>col</code>)
	 */
	public MazeCell getCell(int row, int col) {
		MazeCell target = new MazeCell();
		try{
			target = maze[row][col];
		} catch (IndexOutOfBoundsException ioobe){
			System.out.println("Indices provided are outside of matrix!");
		}
		return target;
	}

	/**
	 *  Tells the viewer to show the maze again, with 
	 *  any changes to cells updated.  The current cell 
	 *  will be colored in the viewer.  If the viewer is null,
	 *  this method does nothing.
	 *  @param cell Current cell, that the viewer will color.
	 */
	public synchronized void visualize(MazeCell cell) {
		viewer.visualize(cell);
	}

	/**
	 *  Generates the maze. 
	 *  The maze is generated by Kruskal's algorithm
	 */
	public synchronized void generateMaze() {
		makeKruskalMaze();
		//you can change the startCell and endCell values
		startCell = maze[0][0];
		endCell = maze[rows-1][cols-1];
	}


	/**
	 *  Forms the maze via Kruskal's algorithm.
	 */
	public synchronized void makeKruskalMaze() {
		ds.makeSet(maze);
		current = new MazeCell();
//		current = getStartCell();
		current = startCell;
		allCells.put(current, new LinkedList<MazeCell>());
		MazeCell neighbor = new MazeCell();
		int totalCells = (getRows() * getCols());
		while(wallDestructions < totalCells - 1) {
			if(current.getRandomNeighbor() != null){
				neighbor = current.getRandomNeighbor();
			} else {
				//				while(neighbor == null){
				Random rand = new Random();
				int randRow = rand.nextInt(rows - 1);
				int randCol = rand.nextInt(cols - 1);
				neighbor = getCell(randRow, randCol);
			}
		
		if(neighbor != null){
			ds.union(current, neighbor);
			current.knockDownWall(current , neighbor);
			allCells.get(current).add(neighbor);
		} 

		current = neighbor;
		if(!allCells.containsKey(current)){	
			//			} else {
			allCells.put(current, new LinkedList<MazeCell>());
		}
		wallDestructions = wallDestructions + 1;
	}
}


/**
 *  Solve maze.  The input parameter is guaranteed
 *  to be one of "dfs", "bfs",  or "random".
 *  @param method The method for solving the maze; one of
 *                "dfs" = depth first search, 
 *                "bfs" = breadth first search, 
 *                "random" = random walk.
 */
public synchronized void solveMaze(String method) {
	if(method.contains("dfs") || method.equalsIgnoreCase("dfs")){
		solveDFSMaze();
	} else if (method.contains("bfs") || method.equalsIgnoreCase("bfs")){
		solveBFSMaze();
	} else if (method.contains("random") || method.equalsIgnoreCase("random")){
		solveRandomMaze();
	} else {
		System.out.println("Please input a valid parameter: 'dfs', 'bfs', or 'random'");
		in = new Scanner(System.in);
		String input = in.next();
		solveMaze(input);
	}
}

/**
 *  Solves the maze by randomly choosing a neighboring
 *  cell to explore. This method has been written for you.
 *  Please note this method takes a very long time
 *  to complete.
 */
public synchronized void solveRandomMaze() {
	// Start the search at the start cell
	MazeCell current = startCell;

	// while we haven't reached the end of the maze
	while(current != endCell) { 
		visualize(current); // show the progress visually (repaint)
		ArrayList<MazeCell> neighbors = current.getNeighbors();
		int index = generator.nextInt(neighbors.size());
		current.examine();
		current = neighbors.get(index);    
	}
	visualize(current);
}

/**
 *  Solves the maze by depth first search.
 */
public synchronized void solveDFSMaze() {
	// Start the search at the start cell
	MazeCell current = startCell;

	// while we haven't reached the end of the maze
	while(current != endCell) { 
		visualize(current); // show the progress visually (repaint)
		ArrayList<MazeCell> neighbors = current.getNeighbors();
		int index = generator.nextInt(neighbors.size());
		current.examine();
		current = neighbors.get(index);    
	}
	visualize(current);
}

/**
 *  Solves the maze by breadth first search.
 *  starts at the start vertex and stops when bfs
 *  discovers the end vertex
 */
public synchronized void solveBFSMaze() {
	//TODO - do a BFS implementation

	for(MazeCell cellName : allCells.keySet()) { //might need to change this
		cellName.color = "white";
		cellName.distance = 0;
		cellName.predecessor = null;
	}
	//		startCell = allCells.get(startCell);
	startCell.color = "white";
	startCell.distance = 0;
	startCell.predecessor = null;

	q.add(startCell);
	while(q.isEmpty() == false){
		MazeCell u = q.remove();
		traversedCells.add(u);
		LinkedList<MazeCell> linked = allCells.get(u);
		//			LinkedList<MazeCell> linked = adjacencies.get(u.value);
		if(linked != null){
			for(MazeCell cell : linked){
				MazeCell currentCell = cell;
				if(currentCell.color.equals("white")){
					currentCell.color = "gray";
					currentCell.distance = u.distance + 1;
					currentCell.predecessor = u;
					//						System.out.println("node: " + currentNode.value + ", node distance:" + currentNode.distance + " , predecessor: " + currentNode.predecessor.value);
					if(!traversedCells.contains(currentCell)){
						q.add(currentCell);
					}
				}
			}
		}
		u.color = "black";
	}
	System.out.println("BFS has finished running!");	
}


}
